## 2-2 지연 초기화와 위임(1)

### 지연 초기화

- 변수, 객체 값 : 생성할 때 초기화 필요
- 필요 이유
    - 프로퍼티 : null 불가
    - **객체의 정보가 나중에 나타나면 그때 초기화 할 수 있어야 함**
        - 메모리 문제 등 방지를 위해
- 종류
    - **lateinit**
    - **lazy**

### lateinit

- **의존성 있는 초기화**
    - Car 클래스의 초기화에 Engine 클래스와 의존성이 있을 때
        - Engine 객체가 생성되지 않으면 완전하게 Car를 초기화 할 수 없는 경우
- **unit 테스트를 위한 코드 작성**
    - 단위(Unit) 테스트를 위해 임시 객체 생성 시
        - 특정 부분 코드 실행
- **프로퍼티 지연 초기화**
    - null 불가
    - lateinit 사용 → 값이 바로 할당되지 않아도 됨

- 제한점
    - **var**로 선언된 프로퍼티만 사용 가능
    - **게터와 세터 불가**

### lazy

- 호출 시점에 **by lazy { }** 정의에 의해 블록 부분 초기화
- **val**만 사용 가능 (읽기 전용)
- **값 변경 불가**

- 3가지 모드
    1. **SYNCHRONIZED**
        1. 락 사용 → 단일 스레드만이 사용 보장(기본 값)
    2. **PUBLICATION**
        1. 여러 군데서 호출 가능, 처음 초기화된 후 반환 값 사용
    3. **NONE**
        1. 락 사용X, 빠름, 다중 스레드 접근 가능(값 일관성 보장 불가)
    

### by 위임

- 하나의 클래스가 다른 클래스에 위임하게 선언
- 위임된 클래스가 가지는 멤버를 **참조 없이 호출**
- **<val | var | class> 프로퍼티/클래스 이름 : 자료형 by 위임자**

- 클래스 위임
    
    ```kotlin
    interface Animal {
        fun eat() { ... }
        ...
    }
    class Cat : Animal { }
    val cat = Cat()
    ```
    
- cat : Animal의 private 멤버, Robot 클래스 내에 저장됨
- 모든 Animal의 메소드는 **정적 메소드**로 생성됨
- **명시적 참조 없이** eat() 호출 가능

- 위임 사용 이유
    - 코틀린 기본 : open 안 된 최종 클래스
        - 무분별한 상속을 막기 위함
        - 그러나 기능 확장이 어려운 문제
    - 위임 사용 시, 상속과 유사하게 최종 클래스 기능 사용 가능
    - **기능을 추가 확장 구현** 가능
- **by lazy{ }** : 위임
    - 사용된 프로퍼티는 람다식 함수에 전달(위임)되어 함수에 의해 사용됨
    - 동작 분석
        - lazy 람다식 함수 : 람다 전달받고 저장한 Lazy<T> 인스턴스 반환
        - 최초 프로퍼티 게터 실행 : lazy에 넘겨진 람다식 함수 실행 후 결과 기록
        - 이후 프로퍼티 게터 실행 : 초기화된, 기록된 값 반환
- **observable**
    - 프로퍼티 감시하다 **특정 코드 로직 변경** → 호출
- **vetoable**
    - 감시X, 수여 → **반환 값에 따라** 프로퍼티 변경 허용하거나 취소